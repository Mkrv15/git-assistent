# Набор основных команд и инструкций в Git
## Как не потеряться
Узнать, где вы сейчас, поможет команда pwd (от англ. print working directory — «показать рабочую папку»).
 Она выводит путь к текущей директории. 
## Вывести содержимое директории — ls
В случае с консолью для отображения файлов и папок используют команду — ls 
(от англ. list directory contents — «отобразить содержимое директории»).  
## Сменить директорию — cd
Следующая важная команда — cd (от англ. change directory — «сменить директорию»). Вы познакомились с ней в прошлом уроке. Она меняет текущую рабочую директорию на ту,
 которая указана в качестве параметра: cd имя_папки.
## Создание файлов и директорий — touch, mkdir
Чтобы создать файл, нужно ввести в консоль команду touch (англ. «коснуться») с
 именем файла в качестве параметра: touch %ИМЯ_ФАЙЛА%.  
```
$ touch my-new-file.txt # создали файл my-new-file.txt
```
  Для создания директорий через терминал используют другую команду — 
  mkdir (от англ. make directory — «создать директорию»).  
  ```
$ mkdir new-dir # создали директорию new-dir
```
## Копирование файлов — cp
 Для копирования файлов через терминал существует команда cp (от англ. copy — «копировать»). 
 В простом виде cp принимает два параметра: что копируем и куда копируем.
 ```
$ cp что_копируем куда_копируем

$ cp index.html src/

скопировали index.html в папку src
```
## Перемещение файлов и папок — mv
Копирование создаёт копию файла или папки. Но иногда вместо копии нужно удалить файл
 в одном месте и создать в другом.
 Для этого есть команда mv (от англ. ***m****o**v**e* — «переместить»).  
 
Синтаксис команды mv аналогичен синтаксису cp. После имени команды указывают список файлов
 и папок, которые нужно переместить, а затем — папку, в которую нужно выполнить перемещение. 
 ## Чтение файлов — cat
 Чтобы прочитать файл, в консоль нужно ввести cat (от англ. concatenate and print — «объединить и распечатать») 
 вместе с именем файла. Команда распечатает то, что содержится в нём.  
```
$ cat myfile.txt # распечатали содержимое файла myfile.txt
```
## Удаление файлов и папок — rm, rmdir, rm -r
Чтобы удалить файл, нужно напечатать команду rm (от англ. remove — «удалить») и передать ей имя файла.
```
$ rm example.txt # удалили файл example.txt из текущей папки
```
Удалить папку можно командой rmdir (от англ. remove 
directory — «удалить директорию»). Не забудьте указать имя папки.  
```
$ rmdir images # команда удалит папку images из текущей директории, 
 # если папка images пуста
```
Это защита от случайного удаления нужных файлов. Если папку всё-таки нужно удалить вместе со всем её
 содержимым, можно использовать команду rm так.  
 ```
$ rm -r images # удалили папку images со всем её содержимым из текущей директории
```
## Настройка Git
Вы можете указать любую электронную почту и любое имя. Сделать это можно с помощью
 команды git config (от англ. configuration — «конфигурация», «настройка») с
 ключом --global (англ. «глобальный»). При этом не имеет значения, в какой директории вы
 находитесь прямо сейчас: вызов git config --global сработает везде.
 В качестве значения user.name нужно указать своё имя или никнейм. Для настройки параметра user.email указывают электронную почту.
 ```
$ git config --global user.name "User Namovich"

имя или ник нужно написать латиницей и в кавычках

$ git config --global user.email username@yandex.ru

здесь нужно указать свой настоящий email
```
 Все глобальные настройки Git хранит в файле .gitconfig в домашней директории. Команда запишет в этот файл указанные имя и почту. Чтобы убедиться в этом, можно вызвать команду для чтения файлов.  
 
```
$ cat \~/.gitconfig
```

## Сделать папку репозиторием — git init
Чтобы Git начал отслеживать изменения в проекте, папку с файлами этого проекта нужно сделать Git-репозиторием (от англ. repository — «хранилище»). Для этого следует переместиться в неё и ввести команду git init (от англ. initialize — «инициализировать»).
```
$ cd ~/dev/first-project # перешли в нужную папку
$ git init # создали репозиторий
```
## «Разгитить» папку, если что-то пошло не так, — rm -rf .git
Если вы случайно сделали Git-репозиторием не ту папку, её можно «разгитить». Для этого нужно удалить скрытую подпапку .git. 
```
$ cd <папка с репозиторием> # перешли в папку

$ rm -rf .git # удалили подпапку .git
``` 
## Проверить состояние репозитория — git status
Команда git status выведет:

- название текущей ветки: On branch master или On branch main;
- сообщение о том, что в репозитории ещё нет коммитов: No commits yet;
- сообщение, которое говорит: «чтобы что-нибудь закоммитить (то есть зафиксировать),
- нужно сначала это создать» — nothing to commit (create/copy files and use "git add"
- to track).

## Хеш — идентификатор коммита
**Хеширование** (от англ. *hash*, «рубить», «крошить», «мешанина») — это способ
преобразовать набор данных и получить их «отпечаток» (англ. *fingerprint*).

Информация о коммите — это набор данных: когда был сделан коммит,
содержимое файлов в репозитории на момент коммита и ссылка на предыдущий,
или **родительский** (англ. *parent*), коммит. Git хеширует (преобразует) эту
информацию с помощью алгоритма **SHA-1** (от англ. ***S****ecure **H**ash
**A**lgorithm* — «безопасный алгоритм хеширования») и получает для каждого коммита
свой уникальный хеш — результат хеширования.

Хеш обладает следующими важными свойствами:

- если хеш получить дважды для одного и того же набора входных данных, то результат будет гарантированно одинаковый;
- если хоть что-то в исходных данных поменяется (хотя бы один символ), то хеш тоже изменится (причём сильно).

Все хеши и таблицу хеш → информация о коммите Git сохраняет в служебные файлы. Они находятся в скрытой папке .git в репозитории проекта.  
## **Исследуем лог**

После вызова git log появляется список коммитов с их описанием.
Если в репозитории уже много коммитов — например, сотни или тысячи, — пригодится сокращённый лог.

Сокращённый лог вызывают командой git log с флагом --oneline (англ. «одной строкой»). При этом в терминале появятся только первые несколько символов хеша каждого коммита и комментарии к ним.
Сокращённый хеш (первые несколько символов полного) можно использовать точно так же, как и полный.  
### **HEAD — всему голова**

При вызове команды git log вы также могли заметить надпись (HEAD -> master) после хеша одного из коммитов.
Файл HEAD (англ. «голова», «головной») — один из служебных файлов папки .git. Он указывает на коммит, который сделан последним (то есть на самый новый). 

Внутри HEAD — ссылка на служебный файл: refs/heads/master (или refs/heads/main в зависимости от названия ветки). Если заглянуть в этот файл, можно увидеть хеш последнего коммита.
```
$ cat refs/heads/master # взяли ссылку из файла HEAD
//внутри хеш
e007f5035f113f9abca78fe2149c593959da5eb7
$ git log
//сверяем с хешем последнего коммита
commit e007f5035f113f9abca78fe2149c593959da5eb7 Author: John Doe johndoe@example.com Date:   Tue Mar 28 00:26:53 2023 +0300
//Добавить амбиций в список дел
... # другие коммиты
```
Когда вы делаете коммит, Git обновляет refs/heads/master — записывает в него хеш последнего коммита. Получается, что HEAD тоже обновляется, так как ссылается на refs/heads/master.
## Зачем нужны статусы файлов и как читать git status
### **Статусы untracked/tracked, staged и modified**



Одна из ключевых задач Git — отслеживать изменения файлов в репозитории. Для этого каждый файл помечается каким-либо статусом. Рассмотрим основные.



- **untracked** (англ. «неотслеживаемый»)
  Новые файлы в Git-репозитории помечаются как untracked, то есть неотслеживаемые. Git «видит», что такой файл существует, но не следит за изменениями в нём. У untracked-файла нет предыдущих версий, зафиксированных в коммитах или через команду git add.



- **staged** (англ. «подготовленный»)
  После выполнения команды git add файл попадает в **staging area** (от англ. *stage* — «сцена», «этап \[процесса\]» и *area* — «область»), то есть в список файлов, которые войдут в коммит. В этот момент файл находится в состоянии staged.
- **tracked** (англ. «отслеживаемый»)

  Состояние tracked — это противоположность untracked. Оно довольно широкое по смыслу: в него попадают файлы, которые уже были зафиксированы с помощью git commit, а также файлы, которые были добавлены в staging area командой git add. То есть все файлы, в которых Git так или иначе отслеживает изменения.


-   **modified** (англ. «изменённый»)

    Состояние modified значит, что Git сравнил содержимое файла с последней сохранённой версией и нашёл отличия. Например, файл был закоммичен и после этого изменён.

Вот что ещё важно учесть:

- Для файлов в состояниях staged и modified обычно не указывается, что они также tracked, потому что это состояние подразумевается.
- Команда git add добавляет в staging area только текущее содержимое файла. Если вы, например, сделаете git add file.txt, а затем измените file.txt, то новое содержимое файла не будет находиться в staging. Git сообщит об этом с помощью статуса modified: файл изменён относительно той версии, которая уже в staging. Чтобы добавить в staging последнюю версию, нужно выполнить git add file.txt ещё раз.
- ### **Какие состояния показывает команда git status**

  git status показывает только следующие состояния файлов:

- staged (Changes to be committed в выводе git status);
- modified (Changes not staged for commit);
- untracked (Untracked files).

# **Оформление сообщений к коммитам**

  То, как написаны сообщения к коммитам, тоже может подчиняться определённым правилам. Иногда эти правила продиктованы культурой команды, а иногда техническими ограничениями. Например, в выводе команды git log --oneline умещается максимум 72 первых символа сообщения, поэтому многие правила включают пункт: «Сообщение не должно быть длиннее 72 символов».  
  Есть общие рекомендации по тому, как правильно составить сообщение. Оно должно быть:

- относительно коротким, чтобы его было легко прочитать;
- информативным.

## **Стили оформления**

Все люди разные и у всех есть предпочтения — в том числе, как формулировать сообщения коммитов. Кто-то использует инфинитивы: Исправить сообщение об ошибке E123, кто-то — глаголы в прошедшем времени: Исправил…, кто-то — существительные: Исправление….

Чтобы упростить работу, команды или даже целые компании часто договариваются об определённом стиле (то есть о правилах) оформления сообщений коммитов.
### **Корпоративный**

Во многих компаниях применяется Jira — система для организации проектов и задач. У каждой задачи в Jira есть идентификатор из нескольких заглавных латинских букв и номера. Например, LGS-239 значит, что это 239-я задача в проекте **LGS** (сокращение от англ. ***l****o**g**istic**s*** — «логистика»).

В корпоративном стиле в начале сообщения обычно указывают Jira-ID, а после — текст сообщения.

`$ git commit -m "LGS-239: Дополнить список пасхалок новыми числами"`
### **Conventional Commits**



Стандарт **Conventional Commits** (англ. «соглашение о коммитах») отличается качественной документацией и подробной проработкой. Он подходит для репозиториев с исходным кодом программ. А вот использовать его для других типов проектов было бы неудобно.

Conventional Commits предлагает такой формат коммита: <type>: <сообщение>. Первая часть type — это тип изменений. Таких типов достаточно много. Вот два примера:

- feat (сокращение от англ. *feature*) — для новой функциональности;
- fix (от англ. «исправить», «устранить») — для исправленных ошибок.

Более подробный список можно увидеть [на сайте с описанием этого стиля](https://www.conventionalcommits.org/ru/v1.0.0-beta.4/#%D1%81%D0%BF%D0%B5%D1%86%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D1%8F).

Например, сообщение может быть таким.

`git commit -m "feat: добавить подсчёт суммы заказов за неделю"`
### **GitHub-стиль**

GitHub можно использовать не только для хранения файлов проекта, но и для ведения списка **задач** (англ. *issue*) этого проекта. Если коммит «закрывает» или «решает» какую-то задачу, то в его сообщении удобно указывать ссылку на неё. Для этого в любом месте сообщения нужно указать #<номер задачи>. Например, вот так.

`$ git commit -m "Исправить #334, добавить график температуры"`



Для сообщений на русском языке часто рекомендуют использовать инфинитивы. Например: Добавить тесты для PipkaService, Исправить ошибку #123 и так далее.

Для сообщений на английском рекомендуется использовать **повелительное наклонение** (англ. *imperative*). Например: Use library mega_lib_300, Fix exit button и так далее.